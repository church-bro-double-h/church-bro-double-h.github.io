---
layout: single
title: "svelte 공식 사이트 Tutorial 정리"
categories: svelte
tag: [svelte, front-end]
comments: true
---

# Introduction

## 1. Adding data
- Script에서 선언한 변수를 Markup에서 사용할 수 있다.
- {변수명}

```html
<script>
  let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

- 놀랍게도 {}(중괄호)가 갖는 의미는 단순히 변수를 사용한다라는 의미보다는 해당 {}(중괄호)안에서 Javascript를 사용할 수 있다는 점에 있는게 아닌가 싶다.
  따라서 아래와 같은 소스의 구현도 가능한 것이다.

```html
<h1>Hello {name.toUpperCase()}</h1>
``` 

## 2.Dynamic attributes
- 중괄호는 엘리먼트의 속성을 조작할 수 있다.

```html
<script>
  let src = '/tutorial/image.gif';
</script>

<img src={src}>
```
- 변수명과 속성명이 동일하다면 아래와 같이 쓸수도 있다.

```html
<script>
  let src = '/tutorial/image.gif';
  let alt = 'this is alt';
</script>

<img {src} {alt}>
```

## 3.Styling
- 일반 HTML파일처럼 Style태그를 가질 수 있다.

```html
<p>This is a paragraph</p>

<style>
  p {
    color:purple;
    font-family: 'Comic Sans MS', cursive;
    font-size: 2em; 
  }
</style>
```


## 4.Nested components
- 원하는 컴포넌트를 다른 파일로부터 끼워넣을 수 있다.
- nest의 사전적 의미 : 4. [동사][전문 용어] (큰 단위의 정보 속에 작은 단위의 정보를) 끼워 넣다
※ 이후 '컴포넌트를 끼워 넣다'라고 표현

App.svelte 존재
Nested.svelte 존재

```html
<script>
  import Nested from './Nested.svelte'
</script>

<p>This is a paragraph.</p>
<Nested/>

<style>
  p {
    color: purple;
    font-family: 'Comic Sans MS', cursive;
    font-size: 2em;
  }
</style>
```
### ★규칙★ 
- 이때 유저가 정의한 컴포넌트와 HTML태그를 구분하기 위해 <span style="color:red">첫글자를 대문자로 </span> 명명하여야 한다.

## 5. HTML tags
- 문자 안의 태그는 기본적으로 String이지만, 해당 HTML태그를 적용하고 싶을때에는 {@html 변수명}을 사용한다.


```html
<p>{@html string}</p>
```
## 6. Making an App
- 원하는 text-editor에서 작업할 수 있도록 빌드 툴을 설치해줘야 되는데, svelte에서는 SvelteKit을 추천한다. Vite를 통해 번들링을 한다.
- SvelteKit을 설치하기 위해서는 원하는 디렉토리로 이동하여 아래와 같은 npm 구문을 써준다.

```console
npm create svelte@latest myapp
```
### 유용한 Tool 안내 페이지
<a href="https://sveltesociety.dev/tools">community-maintained integrations.</a>

### SvelteKit 개발환경 셋팅 안내 페이지
<a href="https://svelte.dev/blog/svelte-for-new-developers">Svelte for new developers</a>

### Client-side component API
<a href="https://svelte.dev/docs#run-time-client-side-component-api">component API</a>

# Reativity

## 1. Assignments
- Svelte의 심장은 어플리케이션의 상태의 Sync를 DOM과 맞추는 강력한 반응성 시스템에 있다.

### 예시 : 버튼을 누름에 따라 바로 횟수 증가
```html
<script>
  let count = 0;

  function incrementCount() {
    // event handler code goes here
    count += 1;
  }
</script>

<button on:click={incrementCount}>
  Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```
## 2. Declarations 
- Svelte는 단순히 DOM영역의 Sync만을 맞추는게 아니라, 변수끼리의 Sync도 맞춰준다.

```html
let count = 0;
$: doubled = count * 2;

<p>{count} doubled is {doubled}</p>
```
- 만약 위 구분이 그저 스크립트로만 구성되어 있었다면,
<br>스크립트를 모두 호출한 다음에 태그의 데이터가 셋팅되므로 '0 doubled is 0'이라고 표시되었을 테지만,
<br>count에 1을 선언한다면 double의 값도 sync가 맞춰저 2가 되고 화면에는 '1 doubled is 2' 라고 표시될 것이다.

## 3. Statements
- $:의 용법은 구문 사용도 가능하다.

```html
$: console.log('the count is ' + count);

$: {
console.log('the count is ' + count);
alert('I SAID THE COUNT IS ' + count);
}

$: if (count >= 10) {
    alert('count is dangerously high!');
    count = 9;
}
```

## 4. Updating arrays and objects
- 배열과 관련된 메소드를 사용하는 경우 반응형으로 sync를 맞춰주지 못하기에 아래와 같은 방법을 사용한다.

### javascript 정석
```javascript
function addNumber() {
	numbers.push(numbers.length + 1);
	numbers = numbers;
}
```
### ES6 spread syntax
```javascript
  function addNumber() {
    numbers[numbers.length] = numbers.length + 1;
  }
```
- 동일한 규칙에 의해 pop, shift, splice 및 Map.set, Set.add와 같은 objects methods 등 또한 위와 같이 사용이 가능하다.
- 그러나 간접적인 참조변수의 할당은 반응성의 트리거를 발생시킬수 없으므로 obj = obj와 같은 형식으로 구현해야 한다.

# Props

## 1. Declaring props
- 하나의 컴포넌트로부터 그것의 자식에게 데이터를 전달해줄 필요가 있을때 특성을 선언해준다.
- 스벨트에서는 export 키워드를 사용해서 위와 같은 작업을 한다.

### 예시

#### App.svelte
```html
<script>
  import Nested from './Nested.svelte';
</script>

<Nested answer={42}/>
```

#### Nested.svelte
```html
<script>
	export let answer;
</script>

<p>The answer is {answer}</p>
```
#### 해설
- App.svelte는 부모이다. Nested.svelte는 자식이다. 부모에서 자식의 변수에 값을 할당하기 위해서는 자식의 변수 앞에 export라는 키워드를 둬야 한다.

## 2. Default values
- 부모-자식간 데이터 할당에 대해서 초기값 설정시 예시

### 예시

#### App.svelte
```html
<script>
  import Nested from './Nested.svelte';
</script>
<Nested answer={42}/>
<Nested/>
```

#### Nested.svelte
```html
<script>
  export let answer = 'a mystery';
</script>
<p>The answer is {answer}</p>
```
#### 해설
- App.svelte에서 line 4에서는 Nested라는 자식 컴포넌트를 만들었고, line 5에서는 똑같이 생겼지만 새로운 자식 컴포넌트를 만들었다.
- 따라서 line 4에서 출력되는 p태그의 변수 값은 42이지만, line 5에서 출력되는 p태그의 변수 값은 값이 대입되지 않았으므로, 할당된 초기값인 a mystery가 출력된다. 

## 3. Spread props
- 부모-자식간 데이터 할당에 대해서 초기값 설정시 예시

### 예시

#### App.svelte 변경전
```html
<script>
  import Info from './Info.svelte';

  const pkg = {
    name: 'svelte',
    version: 3,
    speed: 'blazing',
    website: 'https://svelte.dev'
  };
</script>

<Info name={pkg.name} version={pkg.version} speed={pkg.speed} website={pkg.website}/>
```

#### Info.svelte
```html
<script>
  export let name;
  export let version;
  export let speed;
  export let website;
</script>

<p>
  The <code>{name}</code> package is {speed} fast.
  Download version {version} from <a href="https://www.npmjs.com/package/{name}">npm</a>
  and <a href={website}>learn more here</a>
</p>
```

#### App.svelte 변경 후
```html
<script>
  import Info from './Info.svelte';

  const pkg = {
    name: 'svelte',
    version: 3,
    speed: 'blazing',
    website: 'https://svelte.dev'
  };
</script>

<Info {...pkg}/>
```
### 해설
- App.svelte에서 Info.svelte를 끼워 넣을때 변수에 대해서 일일이 값을 할당해주는 번거로움을 위와 같이 끼워 넣기할 때 spread 구문(...변수명)을 사용하여 값을 할당한다. 

# Logic

## 1. If blocks
- HTML은 로직적인 표현을 사용할수 없지만 조건문과 반복절을 스벨트는 할 수 있다.(JSP처럼...)
- {#if (조건)} : 조건문 열고 조건문 선언
- {/if} : 조건문 닫기

### 예시

#### App.svelte
```html
<script>
  let user = { loggedIn: false };

  function toggle() {
    user.loggedIn = !user.loggedIn;
  }
</script>

{#if user.loggedIn}
<button on:click={toggle}>
  Log out
</button>
{/if}

{#if !user.loggedIn}
<button on:click={toggle}>
  Log in
</button>
{/if}
```

## 2. else blocks
- 상호적으로 독점적인 조건으로 로직이 동작해야 하는 경우 else문을 사용하는게 깔끔한데 아래와 같이 구현 가능하다.
- {:else} : 중간에 있는 svelte구문은 {:머시기}로 구현 가능.

### 예시

#### App.svelte
```html
<script>
  let user = { loggedIn: false };

  function toggle() {
    user.loggedIn = !user.loggedIn;
  }
</script>

{#if user.loggedIn}
<button on:click={toggle}>
  Log out
</button>
{:else}
<button on:click={toggle}>
  Log in
</button>
{/if}
```
#### svelte syntax 설명
- ```#``` : 해당 문자는 언제나 block의 시작을 가리킨다.
- ```/``` : 해당 문자는 언제나 block의 끝을 가리킨다.
- ```:``` : 해당 문자는 언제나 block의 계속되는 태그 가리킨다.

## 3. Else-if blocks
- 다중 조건은 else if로 연결할 수 있다.

```html
<script>
	let x = 7;
</script>

{#if x > 10}
	<p>{x} is greater than 10</p>
{:else if 5 > x}
	<p>{x} is less than 5</p>
{:else}
	<p>{x} is between 5 and 10</p>
{/if}
```

## 4. Each blocks
- 만약에 데이터 목록의 반복 출력을 필요로 한다면 each구문을 사용하면 된다.
- index를 사용하고 싶다면 두번째 인자를 넣으면 된다.

```html
<script>
  let cats = [
    { id: 'J---aiyznGQ', name: 'Keyboard Cat' },
    { id: 'z_AbfPXTKms', name: 'Maru' },
    { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }
  ];
</script>

<h1>The Famous Cats of YouTube</h1>

<ul>
  {#each cats as cat, i}
  <li><a target="_blank" href="https://www.youtube.com/watch?v={cat.id}" rel="noreferrer">
    {i + 1}: {cat.name}
  </a></li>
  {/each}
</ul>
```

- 더 간단하게 구현 예시

```html
<ul>
    {#each cats as { id, name }, i}
        <li>
            <a target="_blank" href="https://www.youtube.com/watch?v={id}" rel="noreferrer">
                {i + 1}: {name}
            </a>
        </li>
    {/each}
</ul>
```

## 5. Keyed each blocks
- each문의 key가 어떻게 설정되어 있는지 이해가 필요하다.

### 예시

#### App.svelte 변경전
```html
<script>
	import Thing from './Thing.svelte';

	let things = [
		{ id: 1, name: 'apple' },
		{ id: 2, name: 'banana' },
		{ id: 3, name: 'carrot' },
		{ id: 4, name: 'doughnut' },
		{ id: 5, name: 'egg' },
	];

	function handleClick() {
		things = things.slice(1);
	}
</script>

<button on:click={handleClick}>
	Remove first thing
</button>

{#each things as thing}
	<Thing name={thing.name}/>
{/each}

```

#### Things .svelte
```html
<script>
  const emojis = {
    apple: "🍎",
    banana: "🍌",
    carrot: "🥕",
    doughnut: "🍩",
    egg: "🥚"
  }

  // the name is updated whenever the prop value changes...
  export let name;

  // ...but the "emoji" variable is fixed upon initialisation of the component
  const emoji = emojis[name];
</script>

<p>
  <span>The emoji for { name } is { emoji }</span>
</p>

<style>
  p {
    margin: 0.8em 0;
  }
  span {
    display: inline-block;
    padding: 0.2em 1em 0.3em;
    text-align: center;
    border-radius: 0.2em;
    background-color: #FFDFD3;
  }
</style>
```

#### App.svelte 변경 후
```html
<script>
	import Thing from './Thing.svelte';

	let things = [
		{ id: 1, name: 'apple' },
		{ id: 2, name: 'banana' },
		{ id: 3, name: 'carrot' },
		{ id: 4, name: 'doughnut' },
		{ id: 5, name: 'egg' },
	];

	function handleClick() {
		things = things.slice(1);
	}
</script>

<button on:click={handleClick}>
	Remove first thing
</button>

{#each things as thing (thing.id)}
    <Thing name={thing.name}/>
{/each}

```
### 해설
- 첫번째 항목 삭제 버튼 클릭시 한줄이 지워지고 내용과 이모지가 일치하여야 되지만, 예상과는 다르게 불일치하게 된다.
- 그 이유는 JS output 탭으로 비교해보면 그렇게 구현되어 있다는 것을 알 수 있다. 따라서 svelte에서는 원하는 id에 맞게 구현될 수 있도록 key라는 기능을 넣었다.

## 6. Await blocks

### Await란?
- Await를 이해하기 위해서는 Promise 객체를 알아야 하고, Promise 객체를 이해하기 위해서는 Javascript에서의 비동기 처리를 이해해야 한다.
- Await 설명 관련 게시물 이동 : <a href='https://church-bro-double-h.github.io/javascript/javascript/' target='_blank' style="color:blue; font-size:12px; font-weight:bold;">비동기처리, Promise, Async & Await</a> 

### 예시

```html
<script>
	async function getRandomNumber() {
		const res = await fetch(`/tutorial/random-number`);
		const text = await res.text();

		if (res.ok) {
			return text;
		} else {
			throw new Error(text);
		}
	}
	
	let promise = getRandomNumber();

	function handleClick() {
		promise = getRandomNumber();
	}
</script>

<button on:click={handleClick}>
	generate random number
</button>

{#await promise}
	<p>...waiting</p>
{:then number}
	<p>The number is {number}</p>
{:catch error}
	<p style="color: red">{error.message}</p>
{/await}

```

### reject하고 싶지 않은 경우
- 아래와 같이 구현

```html
{#await promise then number}
	<p>the number is {number}</p>
{/await}
```

# Events

## DOM events
- ```on:``` 이라는 지시어를 통해 어떤 이벤트도 엘리먼트에 부여할 수 있다. 
- DOM events 종류보기 : <a href='https://www.w3schools.com/jsref/dom_obj_event.asp' target='_blank' style="color:blue; font-size:12px; font-weight:bold;">W3Schools</a>

### 예시

```html
<script>
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
</script>

<div on:mousemove={handleMousemove}>
	The mouse position is {m.x} x {m.y}
</div>

<style>
	div { width: 100%; height: 100%; }
</style>
```

## Inline handlers
- 이벤트 헨들러를 Inline 구문으로 선언할수도 있다.
- 이벤트 핸들러란?
- 

## 참고 사이트
<a href='https://svelte.dev/tutorial/making-an-app' target='_blank' style="color:blue; font-size:12px; font-weight:bold;"># Svelte 공식사이트 튜토리얼</a>